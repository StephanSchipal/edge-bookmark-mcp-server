"""
Complete Export Module for Edge Bookmark MCP Server
Supports JSON, CSV, HTML, XLSX formats with advanced filtering and templates
"""

import json
import logging
import csv
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
from urllib.parse import urlparse
from dataclasses import dataclass

# Try to import optional dependencies
try:
    import pandas as pd
    PANDAS_AVAILABLE = True
except ImportError:
    PANDAS_AVAILABLE = False

try:
    from jinja2 import Environment, BaseLoader, Template
    JINJA2_AVAILABLE = True
except ImportError:
    JINJA2_AVAILABLE = False

from config import config

logger = logging.getLogger(__name__)

@dataclass
class ExportOptions:
    """Export configuration options."""
    include_metadata: bool = True
    include_folder_structure: bool = True
    include_tags: bool = True
    include_dates: bool = True
    flatten_folders: bool = False
    sort_by: str = "title"  # title, url, date_added, folder
    sort_ascending: bool = True
    custom_fields: List[str] = None

class TemplateLoader(BaseLoader):
    """Custom template loader for export templates."""
    
    def __init__(self, templates: Dict[str, str]):
        self.templates = templates
    
    def get_source(self, environment, template):
        if template in self.templates:
            source = self.templates[template]
            return source, None, lambda: True
        raise Exception(f"Template {template} not found")

class BookmarkExporter:
    """Complete bookmark exporter with multiple format support."""
    
    def __init__(self):
        self.supported_formats = ['json', 'csv', 'html', 'xlsx', 'xml', 'yaml']
        self.export_stats = {
            'total_exports': 0,
            'exports_by_format': {},
            'last_export_time': None,
            'total_bookmarks_exported': 0
        }
        
        # Initialize templates
        self.templates = self._initialize_templates()
        self.template_env = None
        if JINJA2_AVAILABLE:
            self.template_env = Environment(loader=TemplateLoader(self.templates))
        
        logger.info(f"ðŸ“¤ BookmarkExporter initialized (pandas: {PANDAS_AVAILABLE}, jinja2: {JINJA2_AVAILABLE})")
    
    def _initialize_templates(self) -> Dict[str, str]:
        """Initialize export templates."""
        return {
            'netscape_html': '''<!DOCTYPE NETSCAPE-Bookmark-file-1>
<!-- Generated by Edge Bookmark MCP Server on {{ export_date }} -->
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
<TITLE>Bookmarks</TITLE>
<H1>Bookmarks</H1>
<DL><p>
{% for folder, bookmarks in folders.items() %}
    {% if folder != 'Root' %}
    <DT><H3 FOLDED>{{ folder }}</H3>
    <DL><p>
    {% endif %}
    {% for bookmark in bookmarks %}
        <DT><A HREF="{{ bookmark.url }}" ADD_DATE="{{ bookmark.date_added_timestamp or 0 }}"{% if bookmark.tags %} TAGS="{{ bookmark.tags | join(',') }}"{% endif %}>{{ bookmark.title or 'Untitled' }}</A>
        {% if bookmark.description %}<DD>{{ bookmark.description }}{% endif %}
    {% endfor %}
    {% if folder != 'Root' %}
    </DL><p>
    {% endif %}
{% endfor %}
</DL><p>
''',
            
            'modern_html': '''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bookmark Collection</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; margin: 40px; }
        .bookmark-folder { margin: 20px 0; }
        .folder-title { font-size: 1.2em; font-weight: bold; color: #333; border-bottom: 1px solid #eee; padding-bottom: 5px; }
        .bookmark-item { margin: 10px 0; padding: 10px; background: #f9f9f9; border-radius: 5px; }
        .bookmark-title { font-weight: bold; color: #0066cc; text-decoration: none; }
        .bookmark-url { color: #666; font-size: 0.9em; word-break: break-all; }
        .bookmark-meta { font-size: 0.8em; color: #999; margin-top: 5px; }
        .tag { background: #e3f2fd; color: #1976d2; padding: 2px 6px; border-radius: 3px; font-size: 0.75em; margin-right: 5px; }
    </style>
</head>
<body>
    <h1>Bookmark Collection</h1>
    <p>Exported on {{ export_date }} | {{ total_bookmarks }} bookmarks</p>
    
    {% for folder, bookmarks in folders.items() %}
    <div class="bookmark-folder">
        <div class="folder-title">{{ folder }} ({{ bookmarks|length }} bookmarks)</div>
        {% for bookmark in bookmarks %}
        <div class="bookmark-item">
            <a href="{{ bookmark.url }}" class="bookmark-title" target="_blank">{{ bookmark.title or 'Untitled' }}</a>
            <div class="bookmark-url">{{ bookmark.url }}</div>
            {% if bookmark.description %}<div>{{ bookmark.description }}</div>{% endif %}
            <div class="bookmark-meta">
                {% if bookmark.tags %}
                    {% for tag in bookmark.tags %}<span class="tag">{{ tag }}</span>{% endfor %}
                {% endif %}
                {% if bookmark.date_added %}| Added: {{ bookmark.date_added }}{% endif %}
            </div>
        </div>
        {% endfor %}
    </div>
    {% endfor %}
</body>
</html>''',
            
            'xml_export': '''<?xml version="1.0" encoding="UTF-8"?>
<bookmarks exported="{{ export_date }}" total="{{ total_bookmarks }}">
{% for bookmark in bookmarks %}
    <bookmark>
        <title><![CDATA[{{ bookmark.title or 'Untitled' }}]]></title>
        <url><![CDATA[{{ bookmark.url }}]]></url>
        <folder><![CDATA[{{ bookmark.folder_path or 'Root' }}]]></folder>
        {% if bookmark.description %}<description><![CDATA[{{ bookmark.description }}]]></description>{% endif %}
        {% if bookmark.date_added %}<date_added>{{ bookmark.date_added }}</date_added>{% endif %}
        {% if bookmark.tags %}
        <tags>
            {% for tag in bookmark.tags %}<tag>{{ tag }}</tag>{% endfor %}
        </tags>
        {% endif %}
    </bookmark>
{% endfor %}
</bookmarks>'''
        }
    
    async def export_bookmarks(
        self,
        bookmarks: List[Dict[str, Any]],
        format: str,
        output_path: str,
        options: Optional[ExportOptions] = None,
        filter_criteria: Optional[Dict[str, Any]] = None
    ) -> str:
        """Export bookmarks to specified format with advanced options."""
        start_time = datetime.now()
        
        if format not in self.supported_formats:
            raise ValueError(f"Unsupported format: {format}. Supported: {self.supported_formats}")
        
        # Set default options
        if options is None:
            options = ExportOptions()
        
        # Apply filters
        filtered_bookmarks = self._apply_filters(bookmarks, filter_criteria)
        
        # Sort bookmarks
        sorted_bookmarks = self._sort_bookmarks(filtered_bookmarks, options)
        
        # Prepare output path
        output_file = Path(output_path)
        output_file.parent.mkdir(parents=True, exist_ok=True)
        
        logger.info(f"ðŸ“¤ Exporting {len(sorted_bookmarks)} bookmarks to {format} format...")
        
        # Export based on format
        result = await self._export_by_format(sorted_bookmarks, format, output_file, options)
        
        # Update statistics
        self._update_export_stats(format, len(sorted_bookmarks), start_time)
        
        logger.info(f"âœ… Export completed: {result}")
        return result
    
    def _apply_filters(
        self, 
        bookmarks: List[Dict[str, Any]], 
        filter_criteria: Optional[Dict[str, Any]]
    ) -> List[Dict[str, Any]]:
        """Apply filtering criteria to bookmarks."""
        if not filter_criteria:
            return bookmarks
        
        filtered = bookmarks.copy()
        
        # Filter by folder
        if 'folder' in filter_criteria:
            folder_filter = filter_criteria['folder'].lower()
            filtered = [b for b in filtered 
                       if folder_filter in b.get('folder_path', '').lower()]
        
        # Filter by domain
        if 'domain' in filter_criteria:
            domain_filter = filter_criteria['domain'].lower()
            filtered = [b for b in filtered if self._get_domain(b.get('url', '')).lower() == domain_filter]
        
        # Filter by tags
        if 'tags' in filter_criteria:
            required_tags = [tag.lower() for tag in filter_criteria['tags']]
            filtered = [b for b in filtered 
                       if any(tag.lower() in [t.lower() for t in b.get('tags', [])] 
                             for tag in required_tags)]
        
        # Filter by date range
        if 'date_from' in filter_criteria or 'date_to' in filter_criteria:
            date_from = filter_criteria.get('date_from')
            date_to = filter_criteria.get('date_to')
            
            def in_date_range(bookmark):
                date_str = bookmark.get('date_added')
                if not date_str:
                    return False
                try:
                    date = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                    if date_from and date < datetime.fromisoformat(date_from):
                        return False
                    if date_to and date > datetime.fromisoformat(date_to):
                        return False
                    return True
                except:
                    return False
            
            filtered = [b for b in filtered if in_date_range(b)]
        
        # Filter by search query
        if 'search' in filter_criteria:
            query = filter_criteria['search'].lower()
            filtered = [b for b in filtered 
                       if query in b.get('title', '').lower() or 
                          query in b.get('url', '').lower() or
                          query in b.get('description', '').lower()]
        
        logger.info(f"ðŸ” Filtered bookmarks: {len(bookmarks)} -> {len(filtered)}")
        return filtered
    
    def _sort_bookmarks(
        self, 
        bookmarks: List[Dict[str, Any]], 
        options: ExportOptions
    ) -> List[Dict[str, Any]]:
        """Sort bookmarks according to options."""
        sort_key_map = {
            'title': lambda b: b.get('title', '').lower(),
            'url': lambda b: b.get('url', '').lower(),
            'folder': lambda b: b.get('folder_path', '').lower(),
            'date_added': lambda b: b.get('date_added', ''),
            'domain': lambda b: self._get_domain(b.get('url', ''))
        }
        
        if options.sort_by in sort_key_map:
            try:
                sorted_bookmarks = sorted(
                    bookmarks,
                    key=sort_key_map[options.sort_by],
                    reverse=not options.sort_ascending
                )
                logger.debug(f"ðŸ“Š Sorted by {options.sort_by} ({'asc' if options.sort_ascending else 'desc'})")
                return sorted_bookmarks
            except Exception as e:
                logger.warning(f"âš ï¸ Sorting failed: {e}, using original order")
        
        return bookmarks
    
    async def _export_by_format(
        self,
        bookmarks: List[Dict[str, Any]],
        format: str,
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export bookmarks in the specified format."""
        format_methods = {
            'json': self._export_json,
            'csv': self._export_csv,
            'html': self._export_html,
            'xlsx': self._export_xlsx,
            'xml': self._export_xml,
            'yaml': self._export_yaml
        }
        
        if format in format_methods:
            return await format_methods[format](bookmarks, output_file, options)
        else:
            raise ValueError(f"Export method not implemented for format: {format}")
    
    async def _export_json(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to JSON format."""
        export_data = {
            'metadata': {
                'exported_at': datetime.now().isoformat(),
                'export_format': 'json',
                'total_bookmarks': len(bookmarks),
                'exported_by': 'Edge Bookmark MCP Server',
                'version': '1.0.0'
            } if options.include_metadata else {},
            'bookmarks': bookmarks
        }
        
        # Add folder structure if requested
        if options.include_folder_structure:
            export_data['folder_structure'] = self._build_folder_structure(bookmarks)
        
        # Add statistics
        if options.include_metadata:
            export_data['statistics'] = self._calculate_export_statistics(bookmarks)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(export_data, f, indent=2, ensure_ascii=False, default=str)
        
        return f"Exported {len(bookmarks)} bookmarks to JSON: {output_file}"
    
    async def _export_csv(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to CSV format."""
        if PANDAS_AVAILABLE:
            return await self._export_csv_pandas(bookmarks, output_file, options)
        else:
            return await self._export_csv_basic(bookmarks, output_file, options)
    
    async def _export_csv_pandas(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to CSV using pandas."""
        # Prepare data for DataFrame
        rows = []
        for bookmark in bookmarks:
            row = {
                'title': bookmark.get('title', ''),
                'url': bookmark.get('url', ''),
                'folder': bookmark.get('folder_path', 'Root'),
                'description': bookmark.get('description', ''),
                'tags': ', '.join(bookmark.get('tags', [])) if options.include_tags else '',
                'date_added': bookmark.get('date_added', '') if options.include_dates else '',
                'profile': bookmark.get('profile', ''),
                'domain': self._get_domain(bookmark.get('url', ''))
            }
            
            # Add custom fields if specified
            if options.custom_fields:
                for field in options.custom_fields:
                    row[field] = bookmark.get(field, '')
            
            rows.append(row)
        
        # Create DataFrame and export
        df = pd.DataFrame(rows)
        df.to_csv(output_file, index=False, encoding='utf-8')
        
        return f"Exported {len(bookmarks)} bookmarks to CSV: {output_file}"
    
    async def _export_csv_basic(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to CSV using basic csv module."""
        fieldnames = ['title', 'url', 'folder', 'description']
        
        if options.include_tags:
            fieldnames.append('tags')
        if options.include_dates:
            fieldnames.append('date_added')
        
        fieldnames.extend(['profile', 'domain'])
        
        if options.custom_fields:
            fieldnames.extend(options.custom_fields)
        
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            
            for bookmark in bookmarks:
                row = {
                    'title': bookmark.get('title', ''),
                    'url': bookmark.get('url', ''),
                    'folder': bookmark.get('folder_path', 'Root'),
                    'description': bookmark.get('description', ''),
                    'profile': bookmark.get('profile', ''),
                    'domain': self._get_domain(bookmark.get('url', ''))
                }
                
                if options.include_tags:
                    row['tags'] = ', '.join(bookmark.get('tags', []))
                if options.include_dates:
                    row['date_added'] = bookmark.get('date_added', '')
                
                # Add custom fields
                if options.custom_fields:
                    for field in options.custom_fields:
                        row[field] = bookmark.get(field, '')
                
                writer.writerow(row)
        
        return f"Exported {len(bookmarks)} bookmarks to CSV: {output_file}"
    
    async def _export_html(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to HTML format."""
        # Group bookmarks by folder
        if options.flatten_folders:
            folders = {'All Bookmarks': bookmarks}
        else:
            folders = self._group_by_folder(bookmarks)
        
        # Prepare template data
        template_data = {
            'export_date': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'total_bookmarks': len(bookmarks),
            'folders': folders,
            'bookmarks': bookmarks
        }
        
        # Add timestamp for Netscape format
        for bookmark in bookmarks:
            timestamp = 0
            if bookmark.get('date_added'):
                try:
                    if bookmark['date_added'].isdigit():
                        timestamp = int(bookmark['date_added']) // 1000000  # Chrome format
                    else:
                        dt = datetime.fromisoformat(bookmark['date_added'].replace('Z', '+00:00'))
                        timestamp = int(dt.timestamp())
                except:
                    pass
            bookmark['date_added_timestamp'] = timestamp
        
        # Choose template based on file extension or options
        if str(output_file).endswith('.netscape.html') or not JINJA2_AVAILABLE:
            template_name = 'netscape_html'
        else:
            template_name = 'modern_html'
        
        if JINJA2_AVAILABLE and self.template_env:
            template = self.template_env.get_template(template_name)
            html_content = template.render(**template_data)
        else:
            # Fallback to basic HTML generation
            html_content = self._generate_basic_html(folders, template_data)
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return f"Exported {len(bookmarks)} bookmarks to HTML: {output_file}"
    
    async def _export_xlsx(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to Excel XLSX format."""
        if not PANDAS_AVAILABLE:
            logger.warning("âš ï¸ pandas not available, falling back to CSV")
            csv_file = output_file.with_suffix('.csv')
            return await self._export_csv_basic(bookmarks, csv_file, options)
        
        try:
            # Create DataFrame
            rows = []
            for bookmark in bookmarks:
                row = {
                    'Title': bookmark.get('title', ''),
                    'URL': bookmark.get('url', ''),
                    'Folder': bookmark.get('folder_path', 'Root'),
                    'Description': bookmark.get('description', ''),
                    'Tags': ', '.join(bookmark.get('tags', [])) if options.include_tags else '',
                    'Date Added': bookmark.get('date_added', '') if options.include_dates else '',
                    'Profile': bookmark.get('profile', ''),
                    'Domain': self._get_domain(bookmark.get('url', ''))
                }
                rows.append(row)
            
            df = pd.DataFrame(rows)
            
            # Export with formatting
            with pd.ExcelWriter(output_file, engine='openpyxl') as writer:
                df.to_excel(writer, sheet_name='Bookmarks', index=False)
                
                # Add summary sheet if metadata requested
                if options.include_metadata:
                    summary_data = {
                        'Metric': ['Total Bookmarks', 'Export Date', 'Unique Folders', 'Unique Domains'],
                        'Value': [
                            len(bookmarks),
                            datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                            len(set(b.get('folder_path', 'Root') for b in bookmarks)),
                            len(set(self._get_domain(b.get('url', '')) for b in bookmarks if b.get('url')))
                        ]
                    }
                    summary_df = pd.DataFrame(summary_data)
                    summary_df.to_excel(writer, sheet_name='Summary', index=False)
            
            return f"Exported {len(bookmarks)} bookmarks to Excel: {output_file}"
            
        except Exception as e:
            logger.error(f"âŒ Excel export failed: {e}")
            # Fallback to CSV
            csv_file = output_file.with_suffix('.csv')
            return await self._export_csv_basic(bookmarks, csv_file, options)
    
    async def _export_xml(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to XML format."""
        template_data = {
            'export_date': datetime.now().isoformat(),
            'total_bookmarks': len(bookmarks),
            'bookmarks': bookmarks
        }
        
        if JINJA2_AVAILABLE and self.template_env:
            template = self.template_env.get_template('xml_export')
            xml_content = template.render(**template_data)
        else:
            # Basic XML generation
            xml_content = f'<?xml version="1.0" encoding="UTF-8"?>\n'
            xml_content += f'<bookmarks exported="{template_data["export_date"]}" total="{len(bookmarks)}">\n'
            
            for bookmark in bookmarks:
                xml_content += '  <bookmark>\n'
                xml_content += f'    <title><![CDATA[{bookmark.get("title", "Untitled")}]]></title>\n'
                xml_content += f'    <url><![CDATA[{bookmark.get("url", "")}]]></url>\n'
                xml_content += f'    <folder><![CDATA[{bookmark.get("folder_path", "Root")}]]></folder>\n'
                
                if bookmark.get('description'):
                    xml_content += f'    <description><![CDATA[{bookmark["description"]}]]></description>\n'
                if bookmark.get('date_added'):
                    xml_content += f'    <date_added>{bookmark["date_added"]}</date_added>\n'
                
                if bookmark.get('tags'):
                    xml_content += '    <tags>\n'
                    for tag in bookmark['tags']:
                        xml_content += f'      <tag>{tag}</tag>\n'
                    xml_content += '    </tags>\n'
                
                xml_content += '  </bookmark>\n'
            
            xml_content += '</bookmarks>'
        
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(xml_content)
        
        return f"Exported {len(bookmarks)} bookmarks to XML: {output_file}"
    
    async def _export_yaml(
        self,
        bookmarks: List[Dict[str, Any]],
        output_file: Path,
        options: ExportOptions
    ) -> str:
        """Export to YAML format."""
        try:
            import yaml
            
            export_data = {
                'metadata': {
                    'exported_at': datetime.now().isoformat(),
                    'total_bookmarks': len(bookmarks),
                    'format': 'yaml'
                } if options.include_metadata else {},
                'bookmarks': bookmarks
            }
            
            with open(output_file, 'w', encoding='utf-8') as f:
                yaml.dump(export_data, f, default_flow_style=False, allow_unicode=True)
            
            return f"Exported {len(bookmarks)} bookmarks to YAML: {output_file}"
            
        except ImportError:
            logger.warning("âš ï¸ PyYAML not available, falling back to JSON")
            json_file = output_file.with_suffix('.json')
            return await self._export_json(bookmarks, json_file, options)
    
    def _generate_basic_html(self, folders: Dict, template_data: Dict) -> str:
        """Generate basic HTML without Jinja2."""
        html = '<!DOCTYPE NETSCAPE-Bookmark-file-1>\n'
        html += '<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">\n'
        html += '<TITLE>Bookmarks</TITLE>\n'
        html += '<H1>Bookmarks</H1>\n'
        html += '<DL><p>\n'
        
        for folder, bookmarks in folders.items():
            if folder != 'Root':
                html += f'<DT><H3 FOLDED>{folder}</H3>\n<DL><p>\n'
            
            for bookmark in bookmarks:
                title = bookmark.get('title', 'Untitled')
                url = bookmark.get('url', '')
                date_added = bookmark.get('date_added_timestamp', 0)
                
                html += f'<DT><A HREF="{url}" ADD_DATE="{date_added}">{title}</A>\n'
                
                if bookmark.get('description'):
                    html += f'<DD>{bookmark["description"]}\n'
            
            if folder != 'Root':
                html += '</DL><p>\n'
        
        html += '</DL><p>\n'
        return html
    
    def _group_by_folder(self, bookmarks: List[Dict[str, Any]]) -> Dict[str, List[Dict[str, Any]]]:
        """Group bookmarks by folder."""
        folders = {}
        
        for bookmark in bookmarks:
            folder = bookmark.get('folder_path', 'Root')
            if folder not in folders:
                folders[folder] = []
            folders[folder].append(bookmark)
        
        return dict(sorted(folders.items()))
    
    def _build_folder_structure(self, bookmarks: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Build hierarchical folder structure."""
        structure = {}
        
        for bookmark in bookmarks:
            folder_path = bookmark.get('folder_path', 'Root')
            parts = folder_path.split('/') if folder_path != 'Root' else ['Root']
            
            current = structure
            for part in parts:
                if part not in current:
                    current[part] = {'subfolders': {}, 'bookmark_count': 0}
                current = current[part]['subfolders']
            
            # Count bookmarks in each folder
            current = structure
            for part in parts:
                current[part]['bookmark_count'] += 1
                current = current[part]['subfolders']
        
        return structure
    
    def _calculate_export_statistics(self, bookmarks: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Calculate statistics for exported bookmarks."""
        total = len(bookmarks)
        
        with_titles = sum(1 for b in bookmarks if b.get('title', '').strip())
        with_descriptions = sum(1 for b in bookmarks if b.get('description', '').strip())
        with_tags = sum(1 for b in bookmarks if b.get('tags'))
        
        folders = set(b.get('folder_path', 'Root') for b in bookmarks)
        domains = set(self._get_domain(b.get('url', '')) for b in bookmarks if b.get('url'))
        
        return {
            'total_bookmarks': total,
            'with_titles': with_titles,
            'with_descriptions': with_descriptions,
            'with_tags': with_tags,
            'unique_folders': len(folders),
            'unique_domains': len(domains),
            'completeness_score': {
                'titles': round((with_titles / total) * 100, 1) if total > 0 else 0,
                'descriptions': round((with_descriptions / total) * 100, 1) if total > 0 else 0,
                'tags': round((with_tags / total) * 100, 1) if total > 0 else 0
            }
        }
    
    def _get_domain(self, url: str) -> str:
        """Extract domain from URL."""
        if not url:
            return ''
        
        try:
            parsed = urlparse(url)
            domain = parsed.netloc.lower()
            if domain.startswith('www.'):
                domain = domain[4:]
            return domain
        except:
            return ''
    
    def _update_export_stats(self, format: str, bookmark_count: int, start_time: datetime) -> None:
        """Update export statistics."""
        self.export_stats['total_exports'] += 1
        self.export_stats['exports_by_format'][format] = self.export_stats['exports_by_format'].get(format, 0) + 1
        self.export_stats['last_export_time'] = datetime.now()
        self.export_stats['total_bookmarks_exported'] += bookmark_count
        
        export_time = (datetime.now() - start_time).total_seconds()
        logger.info(f"ðŸ“Š Export completed in {export_time:.2f}s")
    
    def get_export_statistics(self) -> Dict[str, Any]:
        """Get export statistics."""
        return {
            'total_exports': self.export_stats['total_exports'],
            'exports_by_format': dict(self.export_stats['exports_by_format']),
            'last_export_time': self.export_stats['last_export_time'].isoformat() if self.export_stats['last_export_time'] else None,
            'total_bookmarks_exported': self.export_stats['total_bookmarks_exported'],
            'supported_formats': self.supported_formats,
            'capabilities': {
                'pandas_available': PANDAS_AVAILABLE,
                'jinja2_available': JINJA2_AVAILABLE,
                'advanced_formatting': PANDAS_AVAILABLE and JINJA2_AVAILABLE,
                'excel_support': PANDAS_AVAILABLE
            }
        }
    
    async def validate_export_path(self, output_path: str) -> Dict[str, Any]:
        """Validate export path and permissions."""
        try:
            path = Path(output_path)
            
            # Check if parent directory exists or can be created
            path.parent.mkdir(parents=True, exist_ok=True)
            
            # Test write permissions
            test_file = path.parent / f".test_write_{datetime.now().timestamp()}.tmp"
            test_file.write_text("test")
            test_file.unlink()
            
            return {
                'valid': True,
                'absolute_path': str(path.absolute()),
                'parent_exists': path.parent.exists(),
                'writable': True,
                'size_limit': None  # Could add size checks here
            }
            
        except Exception as e:
            return {
                'valid': False,
                'error': str(e),
                'absolute_path': str(Path(output_path).absolute()),
                'parent_exists': False,
                'writable': False
            }

            '